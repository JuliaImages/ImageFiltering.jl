<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Filtering images · ImageFiltering</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../democards/gridtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="ImageFiltering logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ImageFiltering</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">ImageFiltering.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/tutorial1/">Tutorial 1</a></li></ul></li><li><a class="tocitem" href="../demos/">Examples</a></li><li class="is-active"><a class="tocitem" href>Filtering images</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Function-options"><span>Function options</span></a></li><li><a class="tocitem" href="#Convolution-versus-correlation"><span>Convolution versus correlation</span></a></li><li><a class="tocitem" href="#Miscellaneous-border-padding-options"><span>Miscellaneous border padding options</span></a></li><li><a class="tocitem" href="#The-imfilter!-function"><span>The <code>imfilter!</code> function</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../kernels/">Kernels</a></li><li><a class="tocitem" href="../gradients/">Gradients</a></li><li><a class="tocitem" href="../mapwindows/">Map window</a></li><li><a class="tocitem" href="../padarrays/">Padding arrays</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../reference/technical/">Technical overview</a></li><li><a class="tocitem" href="../reference/function_reference/">Function reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Filtering images</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Filtering images</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/master/docs/src/filters.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Filtering-images"><a class="docs-heading-anchor" href="#Filtering-images">Filtering images</a><a id="Filtering-images-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-images" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>The ImageFilters.jl package provides tools for applying transformations to arrays, with a particular focus on the kinds of operations used in image processing, such as blurring, sharpening, and edge-enhancement.</p><p>The term <em>filtering</em> emerges in the context of a Fourier transformation of an image, which maps an image from its canonical spatial domain to its concomitant frequency domain. Manipulating an image in the frequency domain amounts to retaining or discarding particular frequency components —- a process analogous to sifting or filtering [1]. Because the Fourier transform establishes a link between the spatial and frequency representation of an image, one can interpret various image manipulations in the spatial domain as filtering operations which accept or reject specific frequencies.</p><p>The phrase <em>spatial filtering</em> is often used to emphasize that an operation is, at least conceptually, devised in the context of the spatial domain of an image. We further distinguish between linear and non-linear spatial filtering. A filter is called <em>linear</em> if the operation performed on the pixels is linear, and is labeled non-linear otherwise.</p><h2 id="Function-options"><a class="docs-heading-anchor" href="#Function-options">Function options</a><a id="Function-options-1"></a><a class="docs-heading-anchor-permalink" href="#Function-options" title="Permalink"></a></h2><p>The <code>imfilter()</code> function filters a one, two or multidimensional array <code>img</code> with a <code>kernel</code> by computing their correlation.</p><p>The syntax for <code>imfilter()</code> is as follows:</p><pre><code class="language-julia hljs">imfilter([T], img, kernel, [border=&quot;replicate&quot;], [alg])
imfilter([r], img, kernel, [border=&quot;replicate&quot;], [alg])
imfilter(r, T, img, kernel, [border=&quot;replicate&quot;], [alg])</code></pre><p>The following subsections describe valid options for the function arguments in more detail.</p><h3 id="Choices-for-r"><a class="docs-heading-anchor" href="#Choices-for-r">Choices for <code>r</code></a><a id="Choices-for-r-1"></a><a class="docs-heading-anchor-permalink" href="#Choices-for-r" title="Permalink"></a></h3><p>Optionally, you can dispatch to different implementations by passing in a resource <code>r</code> as defined by the <a href="https://github.com/timholy/ComputationalResources.jl">ComputationalResources</a> package.</p><p>For example:</p><pre><code class="language-julia hljs">imfilter(ArrayFireLibs(), img, kernel)</code></pre><p>would request that the computation be performed on the GPU using the ArrayFire libraries.</p><h3 id="Choices-for-T"><a class="docs-heading-anchor" href="#Choices-for-T">Choices for <code>T</code></a><a id="Choices-for-T-1"></a><a class="docs-heading-anchor-permalink" href="#Choices-for-T" title="Permalink"></a></h3><p>Optionally, you can control the element type of the output image by passing in a type <code>T</code> as the first argument.</p><h3 id="Choices-for-img"><a class="docs-heading-anchor" href="#Choices-for-img">Choices for <code>img</code></a><a id="Choices-for-img-1"></a><a class="docs-heading-anchor-permalink" href="#Choices-for-img" title="Permalink"></a></h3><p>You must provide a one, two, or multidimensional array as the input image.</p><h3 id="Choices-for-kernel"><a class="docs-heading-anchor" href="#Choices-for-kernel">Choices for <code>kernel</code></a><a id="Choices-for-kernel-1"></a><a class="docs-heading-anchor-permalink" href="#Choices-for-kernel" title="Permalink"></a></h3><p>The <code>kernel[0, 0,..]</code> parameter corresponds to the origin (zero displacement) of the kernel; you can use <code>centered</code> to place the origin at the array center, or use the OffsetArrays package to set <code>kernel</code>&#39;s indices manually. For example, to filter with a random <em>centered</em> 3x3 kernel, you could use either of the following:</p><pre><code class="language-julia hljs">kernel = centered(rand(3,3))
kernel = OffsetArray(rand(3,3), -1:1, -1:1)</code></pre><p>The <code>kernel</code> parameter can be specified as an array or as a &quot;factored kernel&quot;, a tuple <code>(filt1, filt2, ...)</code> of filters to apply along each axis of the image. In cases where you know your kernel is separable, this format can speed processing. Each of these should have the same dimensionality as the image itself, and be shaped in a manner that indicates the filtering axis, e.g., a 3x1 filter for filtering the first dimension and a 1x3 filter for filtering the second dimension. In two dimensions, any kernel passed as a single matrix is checked for separability; if you want to eliminate that check, pass the kernel as a single-element tuple, <code>(kernel,)</code>.</p><h3 id="Choices-for-border"><a class="docs-heading-anchor" href="#Choices-for-border">Choices for <code>border</code></a><a id="Choices-for-border-1"></a><a class="docs-heading-anchor-permalink" href="#Choices-for-border" title="Permalink"></a></h3><p>At the image edge, <code>border</code> is used to specify the padding which will be used to extrapolate the image beyond its original bounds. </p><p>As an indicative example of each option, the results of the padding are illustrated on an image consisting of a row of six pixels which are specified alphabetically: </p><pre><code class="language-plain hljs">        ┏━━━━━━┓ 
        ┃abcdef┃ 
        ┗━━━━━━┛ </code></pre><p>We show the effects of padding only on the left and right border, but analogous consequences hold for the top and bottom border.</p><h4 id="&quot;replicate&quot;-(default)"><a class="docs-heading-anchor" href="#&quot;replicate&quot;-(default)"><code>&quot;replicate&quot;</code> (default)</a><a id="&quot;replicate&quot;-(default)-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;replicate&quot;-(default)" title="Permalink"></a></h4><p>The border pixels extend beyond the image boundaries.</p><pre><code class="language-plain hljs">   ╭────┏━━━━━━┓────╮
   │aaaa┃abcdef┃ffff│
   ╰────┗━━━━━━┛────╯</code></pre><h4 id="&quot;circular&quot;"><a class="docs-heading-anchor" href="#&quot;circular&quot;"><code>&quot;circular&quot;</code></a><a id="&quot;circular&quot;-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;circular&quot;" title="Permalink"></a></h4><p>The border pixels wrap around. For instance, indexing beyond the left border returns values starting from the right border.</p><pre><code class="language-plain hljs">
   ╭────┏━━━━━━┓────╮
   │cdef┃abcdef┃abcd│
   ╰────┗━━━━━━┛────╯
</code></pre><h4 id="&quot;reflect&quot;"><a class="docs-heading-anchor" href="#&quot;reflect&quot;"><code>&quot;reflect&quot;</code></a><a id="&quot;reflect&quot;-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;reflect&quot;" title="Permalink"></a></h4><p>The border pixels reflect relative to a position between pixels. That is, the border pixel is omitted when mirroring.</p><pre><code class="language-plain hljs">
   ╭────┏━━━━━━┓────╮
   │dcba┃abcdef┃fedc│
   ╰────┗━━━━━━┛────╯
</code></pre><h4 id="&quot;symmetric&quot;"><a class="docs-heading-anchor" href="#&quot;symmetric&quot;"><code>&quot;symmetric&quot;</code></a><a id="&quot;symmetric&quot;-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;symmetric&quot;" title="Permalink"></a></h4><p>The border pixels reflect relative to the edge itself.</p><pre><code class="language-plain hljs">
   ╭────┏━━━━━━┓────╮
   │edcb┃abcdef┃edcb│
   ╰────┗━━━━━━┛────╯
</code></pre><h4 id="Fill(m)"><a class="docs-heading-anchor" href="#Fill(m)"><code>Fill(m)</code></a><a id="Fill(m)-1"></a><a class="docs-heading-anchor-permalink" href="#Fill(m)" title="Permalink"></a></h4><p>The border pixels are filled with a specified value <span>$m$</span>.</p><pre><code class="language-plain hljs">
   ╭────┏━━━━━━┓────╮
   │mmmm┃abcdef┃mmmm│
   ╰────┗━━━━━━┛────╯
</code></pre><h4 id="Inner()"><a class="docs-heading-anchor" href="#Inner()"><code>Inner()</code></a><a id="Inner()-1"></a><a class="docs-heading-anchor-permalink" href="#Inner()" title="Permalink"></a></h4><p>Indicate that edges are to be discarded in filtering, only the interior of the result is to be returned.</p><h4 id="NA()"><a class="docs-heading-anchor" href="#NA()"><code>NA()</code></a><a id="NA()-1"></a><a class="docs-heading-anchor-permalink" href="#NA()" title="Permalink"></a></h4><p>Choose filtering using &quot;NA&quot; (Not Available) boundary conditions. This is most appropriate for filters that have only positive weights summing to 1, such as blurring filters–-rather than &quot;make up&quot; values beyond the edges, the result is normalized by the number of in-bounds pixels (similar to <a href="https://brenhinkeller.github.io/NaNStatistics.jl/dev/#NaNStatistics.nanmean-Tuple{Any}"><code>nanmean</code></a>).</p><p>For example:</p><pre><code class="language-julia hljs">julia&gt; img = [0, 0, 1, 0, 0, 0, 1];

julia&gt; imfilter(img, centered([1, 1, 1]/3), NA())
7-element Vector{Float64}:
 0.0
 0.3333333333333333
 0.3333333333333333
 0.3333333333333333
 0.0
 0.3333333333333333
 0.5</code></pre><p>See also: <a href="../reference/function_reference/#ImageFiltering.Pad"><code>Pad</code></a>, <a href="../reference/function_reference/#ImageFiltering.padarray"><code>padarray</code></a>, <a href="../reference/function_reference/#ImageFiltering.Inner"><code>Inner</code></a>, <a href="../reference/function_reference/#ImageFiltering.NA"><code>NA</code></a>  and <a href="../reference/function_reference/#ImageFiltering.NoPad"><code>NoPad</code></a></p><h3 id="Choices-for-alg"><a class="docs-heading-anchor" href="#Choices-for-alg">Choices for <code>alg</code></a><a id="Choices-for-alg-1"></a><a class="docs-heading-anchor-permalink" href="#Choices-for-alg" title="Permalink"></a></h3><p>The <code>alg</code> parameter allows you to choose the particular algorithm: <code>Algorithm.FIR()</code> (finite impulse response, aka traditional digital filtering) or <code>Algorithm.FFT()</code> (Fourier-based filtering). If no choice is specified, one will be chosen based on the size of the image and kernel in a way that strives to deliver good performance. Alternatively you can use a custom filter type, like <a href="../reference/function_reference/#ImageFiltering.KernelFactors.IIRGaussian"><code>KernelFactors.IIRGaussian</code></a>.</p><h2 id="Convolution-versus-correlation"><a class="docs-heading-anchor" href="#Convolution-versus-correlation">Convolution versus correlation</a><a id="Convolution-versus-correlation-1"></a><a class="docs-heading-anchor-permalink" href="#Convolution-versus-correlation" title="Permalink"></a></h2><p>The default operation of <code>imfilter</code> is correlation. </p><p>In the following example, consider the image matrix <code>f</code> and a centered filter coefficient mask <code>w</code>.</p><p>The specification <code>Fill(0, w)</code> indicates that we wish to pad the border of <code>f</code> with zeros. The amount of padding is automatically determined by considering the length of <code>w</code>.</p><pre><code class="language-julia hljs"># Create a two-dimensional discrete unit impulse function.
f = fill(0, (9, 9));
f[5, 5] = 1

# Specify a filter coefficient mask and set the center of the mask as the origin.
w = centered([1 2 3; 4 5 6 ; 7 8 9]);</code></pre><p>By reflecting <code>w</code> we compute the convolution of <code>f</code> and <code>w</code>. Compare the correlation and convolution:</p><pre><code class="language-julia hljs">correlation = imfilter(f, w, Fill(0, w))
convolution = imfilter(f, reflect(w), Fill(0, w))</code></pre><h2 id="Miscellaneous-border-padding-options"><a class="docs-heading-anchor" href="#Miscellaneous-border-padding-options">Miscellaneous border padding options</a><a id="Miscellaneous-border-padding-options-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous-border-padding-options" title="Permalink"></a></h2><p>Given the following example values:</p><pre><code class="language-julia hljs">f = reshape(1.0:81.0, 9, 9)
w = centered(reshape(1.0:9.0, 3, 3))</code></pre><p>you can designate the type of padding by supplying an appropriate string:</p><pre><code class="language-julia hljs">imfilter(f, w, &quot;replicate&quot;)
imfilter(f, w, &quot;circular&quot;)
imfilter(f, w, &quot;symmetric&quot;)
imfilter(f, w, &quot;reflect&quot;)</code></pre><p>Alternatively, you can explicitly use the <code>Pad</code> type to designate the padding style:</p><pre><code class="language-julia hljs">imfilter(f, w, Pad(:replicate))
imfilter(f, w, Pad(:circular))
imfilter(f, w, Pad(:symmetric))
imfilter(f, w, Pad(:reflect))</code></pre><p>If you want to pad with a specific value, use the <code>Fill</code> type.</p><pre><code class="language-julia hljs">imfilter(f, w, Fill(0, w))
imfilter(f, w, Fill(1, w))
imfilter(f, w, Fill(-1, w))</code></pre><p>Specify <code>Inner()</code> if you want to retrieve the interior sub-array of f for which the filtering operation is defined without padding:</p><pre><code class="language-julia hljs">imfilter(f, w, Inner())</code></pre><h2 id="The-imfilter!-function"><a class="docs-heading-anchor" href="#The-imfilter!-function">The <code>imfilter!</code> function</a><a id="The-imfilter!-function-1"></a><a class="docs-heading-anchor-permalink" href="#The-imfilter!-function" title="Permalink"></a></h2><p>The <code>imfilter!()</code> function filters an array <code>img</code> with kernel <code>kernel</code> by computing their correlation, storing the result in <code>imgfilt</code>.</p><pre><code class="language-julia hljs">imfilter!(imgfilt, img, kernel, [border=&quot;replicate&quot;], [alg])
imfilter!(r, imgfilt, img, kernel, border::Pad)
imfilter!(r, imgfilt, img, kernel, border::NoPad, [inds=axes(imgfilt)])</code></pre><p>The indices of <code>imgfilt</code> determine the region over which the filtered image is computed – you can use this fact to select just a specific region of interest, although be aware that the input <code>img</code> might still get padded.</p><p>Alteratively, explicitly provide the indices <code>inds</code> of <code>imgfilt</code> that you want to calculate, and use <code>NoPad</code> boundary conditions. In such cases, you are responsible for supplying appropriate padding: <code>img</code> must be indexable for all of the locations needed for calculating the output. This syntax is best-supported for FIR filtering; in particular, the IIR filtering can lead to results that are inconsistent with respect to filtering the entire array.</p><p>See also: <a href="../reference/function_reference/#ImageFiltering.imfilter"><code>imfilter</code></a>, <a href="../reference/function_reference/#OffsetArrays.centered"><code>centered</code></a>, <a href="../reference/function_reference/#ImageFiltering.padarray"><code>padarray</code></a>, <a href="../reference/function_reference/#ImageFiltering.Pad"><code>Pad</code></a>, <a href="../reference/function_reference/#ImageFiltering.Fill"><code>Fill</code></a>, <a href="../reference/function_reference/#ImageFiltering.Inner"><code>Inner</code></a>, <a href="../reference/function_reference/#ImageFiltering.KernelFactors.IIRGaussian"><code>KernelFactors.IIRGaussian</code></a>.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ol><li>R. C. Gonzalez and R. E. Woods. <em>Digital Image Processing (3rd Edition)</em>.  Upper Saddle River, NJ, USA: Prentice-Hall,  2006.</li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../demos/">« Examples</a><a class="docs-footer-nextpage" href="../kernels/">Kernels »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 31 May 2023 18:03">Wednesday 31 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
