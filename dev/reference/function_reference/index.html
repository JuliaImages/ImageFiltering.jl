<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function reference · ImageFiltering</title><meta name="title" content="Function reference · ImageFiltering"/><meta property="og:title" content="Function reference · ImageFiltering"/><meta property="twitter:title" content="Function reference · ImageFiltering"/><meta name="description" content="Documentation for ImageFiltering."/><meta property="og:description" content="Documentation for ImageFiltering."/><meta property="twitter:description" content="Documentation for ImageFiltering."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../democards/gridtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="ImageFiltering logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ImageFiltering</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">ImageFiltering.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/tutorial1/">Tutorial 1</a></li></ul></li><li><a class="tocitem" href="../../demos/">Examples</a></li><li><a class="tocitem" href="../../filters/">Filtering images</a></li><li><a class="tocitem" href="../../kernels/">Kernels</a></li><li><a class="tocitem" href="../../gradients/">Gradients</a></li><li><a class="tocitem" href="../../mapwindows/">Map window</a></li><li><a class="tocitem" href="../../padarrays/">Padding arrays</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../technical/">Technical overview</a></li><li class="is-active"><a class="tocitem" href>Function reference</a><ul class="internal"><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Kernel"><span>Kernel</span></a></li><li><a class="tocitem" href="#KernelFactors"><span>KernelFactors</span></a></li><li><a class="tocitem" href="#Kernel-utilities"><span>Kernel utilities</span></a></li><li><a class="tocitem" href="#Boundaries-and-padding"><span>Boundaries and padding</span></a></li><li><a class="tocitem" href="#Find-local-extrema"><span>Find local extrema</span></a></li><li><a class="tocitem" href="#Algorithms"><span>Algorithms</span></a></li><li><a class="tocitem" href="#Solvers-for-predefined-models"><span>Solvers for predefined models</span></a></li><li><a class="tocitem" href="#Internal-machinery"><span>Internal machinery</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Function reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaImages/ImageFiltering.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Filtering-functions"><a class="docs-heading-anchor" href="#Filtering-functions">Filtering functions</a><a id="Filtering-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-functions" title="Permalink"></a></h1><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.imfilter" href="#ImageFiltering.imfilter"><code>ImageFiltering.imfilter</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">imfilter([T], img, kernel, [border=&quot;replicate&quot;], [alg]) --&gt; imgfilt
imfilter([r], img, kernel, [border=&quot;replicate&quot;], [alg]) --&gt; imgfilt
imfilter(r, T, img, kernel, [border=&quot;replicate&quot;], [alg]) --&gt; imgfilt</code></pre><p>Filter a one, two or multidimensional array <code>img</code> with a <code>kernel</code> by computing their correlation.</p><p><strong>Extended help</strong></p><p><strong>Choices for <code>r</code></strong></p><p>Optionally, you can dispatch to different implementations by passing in a resource <code>r</code> as defined by the <a href="https://github.com/timholy/ComputationalResources.jl">ComputationalResources</a> package.</p><p>For example:</p><pre><code class="language-julia hljs">imfilter(ArrayFireLibs(), img, kernel)</code></pre><p>would request that the computation be performed on the GPU using the ArrayFire libraries.</p><p><strong>Choices for <code>T</code></strong></p><p>Optionally, you can control the element type of the output image by passing in a type <code>T</code> as the first argument.</p><p><strong>Choices for <code>img</code></strong></p><p>You can specify a one, two, or multidimensional array defining your image.</p><p><strong>Choices for <code>kernel</code></strong></p><p>The <code>kernel[0, 0,..]</code> parameter corresponds to the origin (zero displacement) of the kernel; you can use <code>centered</code> to place the origin at the array center, or use the OffsetArrays package to set <code>kernel</code>&#39;s indices manually. For example, to filter with a random <em>centered</em> 3x3 kernel, you could use either of the following:</p><pre><code class="language-julia hljs">kernel = centered(rand(3,3))
kernel = OffsetArray(rand(3,3), -1:1, -1:1)</code></pre><p>The <code>kernel</code> parameter can be specified as an array or as a &quot;factored kernel&quot;, a tuple <code>(filt1, filt2, ...)</code> of filters to apply along each axis of the image. In cases where you know your kernel is separable, this format can speed processing. Each of these should have the same dimensionality as the image itself, and be shaped in a manner that indicates the filtering axis, e.g., a 3x1 filter for filtering the first dimension and a 1x3 filter for filtering the second dimension. In two dimensions, any kernel passed as a single matrix is checked for separability; if you want to eliminate that check, pass the kernel as a single-element tuple, <code>(kernel,)</code>.</p><p><strong>Choices for <code>border</code></strong></p><p>At the image edge, <code>border</code> is used to specify the padding which will be used to extrapolate the image beyond its original bounds.</p><p><strong><code>&quot;replicate&quot;</code> (default)</strong></p><p>The border pixels extend beyond the image boundaries.</p><pre><code class="language-plain hljs">   ╭────┏━━━━━━┓────╮
   │aaaa┃abcdef┃ffff│
   ╰────┗━━━━━━┛────╯</code></pre><p><strong><code>&quot;circular&quot;</code></strong></p><p>The border pixels wrap around. For instance, indexing beyond the left border returns values starting from the right border.</p><pre><code class="language-plain hljs">
   ╭────┏━━━━━━┓────╮
   │cdef┃abcdef┃abcd│
   ╰────┗━━━━━━┛────╯
</code></pre><p><strong><code>&quot;reflect&quot;</code></strong></p><p>The border pixels reflect relative to a position between pixels. That is, the border pixel is omitted when mirroring.</p><pre><code class="language-plain hljs">
   ╭────┏━━━━━━┓────╮
   │dcba┃abcdef┃fedc│
   ╰────┗━━━━━━┛────╯
</code></pre><p><strong><code>&quot;symmetric&quot;</code></strong></p><p>The border pixels reflect relative to the edge itself.</p><pre><code class="language-plain hljs">
   ╭────┏━━━━━━┓────╮
   │edcb┃abcdef┃edcb│
   ╰────┗━━━━━━┛────╯
</code></pre><p><strong><code>Fill(m)</code></strong></p><p>The border pixels are filled with a specified value <span>$m$</span>.</p><pre><code class="language-plain hljs">
   ╭────┏━━━━━━┓────╮
   │mmmm┃abcdef┃mmmm│
   ╰────┗━━━━━━┛────╯
</code></pre><p><strong><code>Inner()</code></strong></p><p>Indicate that edges are to be discarded in filtering, only the interior of the result is to be returned.</p><p><strong><code>NA()</code></strong></p><p>Choose filtering using &quot;NA&quot; (Not Available) boundary conditions. This is most appropriate for filters that have only positive weights, such as blurring filters.</p><p>See also: <a href="#ImageFiltering.Pad"><code>Pad</code></a>, <a href="#ImageFiltering.padarray"><code>padarray</code></a>, <a href="#ImageFiltering.Inner"><code>Inner</code></a>, <a href="#ImageFiltering.NA"><code>NA</code></a>  and <a href="#ImageFiltering.NoPad"><code>NoPad</code></a></p><p><strong>Choices for <code>alg</code></strong></p><p>The <code>alg</code> parameter allows you to choose the particular algorithm: <code>Algorithm.FIR()</code> (finite impulse response, aka traditional digital filtering) or <code>Algorithm.FFT()</code> (Fourier-based filtering). If no choice is specified, one will be chosen based on the size of the image and kernel in a way that strives to deliver good performance. Alternatively you can use a custom filter type, like <a href="#ImageFiltering.KernelFactors.IIRGaussian"><code>KernelFactors.IIRGaussian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/imfilter.jl#L51-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.imfilter!" href="#ImageFiltering.imfilter!"><code>ImageFiltering.imfilter!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">imfilter!(imgfilt, img, kernel, [border=&quot;replicate&quot;], [alg])
imfilter!(r, imgfilt, img, kernel, border::Pad)
imfilter!(r, imgfilt, img, kernel, border::NoPad, [inds=axes(imgfilt)])</code></pre><p>Filter an array <code>img</code> with kernel <code>kernel</code> by computing their correlation, storing the result in <code>imgfilt</code>.</p><p>The indices of <code>imgfilt</code> determine the region over which the filtered image is computed–-you can use this fact to select just a specific region of interest, although be aware that the input <code>img</code> might still get padded.  Alteratively, explicitly provide the indices <code>inds</code> of <code>imgfilt</code> that you want to calculate, and use <code>NoPad</code> boundary conditions. In such cases, you are responsible for supplying appropriate padding: <code>img</code> must be indexable for all of the locations needed for calculating the output. This syntax is best-supported for FIR filtering; in particular, that that IIR filtering can lead to results that are inconsistent with respect to filtering the entire array.</p><p>See also: <a href="#ImageFiltering.imfilter"><code>imfilter</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/imfilter.jl#L256-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.imgradients" href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>imgradients(img, kernelfun=KernelFactors.ando3, border=&quot;replicate&quot;) -&gt; gimg1, gimg2, ...</p><p>Estimate the gradient of <code>img</code> in the direction of the first and second dimension at all points of the image, using a kernel specified by <code>kernelfun</code>.</p><p>Returns a tuple-of-arrays, <code>(gimg1, gimg2, ...)</code>, one for each dimension of the input: <code>gimg1</code> corresponds to the derivative with respect to the first dimension, <code>gimg2</code> to the second, and so on.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Images, ImageFiltering, TestImages
img = testimage(&quot;mandrill&quot;)
imgr = imgradients(img, KernelFactors.sobel, &quot;reflect&quot;)
mosaicview(imgr...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/specialty.jl#L20-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.MapWindow.mapwindow" href="#ImageFiltering.MapWindow.mapwindow"><code>ImageFiltering.MapWindow.mapwindow</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mapwindow(f::F, img, window; 
    border = &quot;replicate&quot;,
    indices = default_imginds(img, window, border), callmode=:copy!)</code></pre><p>Apply <code>f</code> to sliding windows of <code>img</code><code>, with window size or axes specified by window. For example,</code>mapwindow(median!, img, window)<code>returns an Array of values similar to</code>img<code>(median-filtered, of course), whereas</code>mapwindow(extrema, img, window)<code>returns an Array of (min, max) tuples over a window of size window centered on each point of</code>img`.</p><p>The function <code>f</code> receives a buffer <code>buf</code>` for the window of data surrounding the current point.</p><p>If <code>window</code>` is specified as a Dims-tuple (tuple-of-integers), then all the integers must be odd and the window is centered around the current image point. </p><p>For example, if <code>window = (3,3)</code>, then <code>f</code> will receive an Array <code>buf</code><code>corresponding to offsets (-1:1, -1:1) from the</code>imgf[i, j]`<code>for which this is currently being computed. Alternatively, window can be a tuple of</code>AbstractUnitRange<code>s, in which case the specified ranges are used for</code>buf`; this allows you to use asymmetric windows if needed.</p><p><strong>Restricting to a subimage</strong></p><p>The <code>indices</code> keyword allows you to omit unnecessary computations, if you want to do things like <code>mapwindow</code> on a subimage, or a strided variant of mapwindow.</p><p>This call:</p><pre><code class="language-julia hljs">mapwindow(f, img, window, indices=(2:5, 1:2:7))</code></pre><p>is more efficient than the equivalent:</p><pre><code class="language-julia hljs">mapwindow(f, img, window)[2:5, 1:2:7]</code></pre><p>because it omits computation of the unused values.</p><p>Because the data in the buffer <code>buf</code> that is received by <code>f</code> is copied from <code>img</code>, and the buffer&#39;s memory is reused, <code>f</code> should not return references to <code>buf</code>.</p><p>This code:</p><pre><code class="language-julia hljs">f = buf -&gt; copy(buf) # as opposed to f = buf -&gt; buf
mapwindow(f, img, window, indices=(2:5, 1:2:7))</code></pre><p>would work as expected.</p><p>For functions that can only take <code>AbstractVector</code> inputs, you might have to first specialize <code>default_shape</code>:</p><pre><code class="language-julia hljs">f = v -&gt; quantile(v, 0.75)
ImageFiltering.MapWindow.default_shape(::typeof(f)) = vec</code></pre><p>and then <code>mapwindow(f, img, (m, n))</code> should filter at the 75th quantile.</p><p>See also: <a href="#ImageFiltering.imfilter"><code>imfilter</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/mapwindow.jl#L12-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.MapWindow.mapwindow!" href="#ImageFiltering.MapWindow.mapwindow!"><code>ImageFiltering.MapWindow.mapwindow!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mapwindow!(f, out, img, window; border=&quot;replicate&quot;, indices=axes(img))</code></pre><p>Variant of <a href="#ImageFiltering.MapWindow.mapwindow"><code>mapwindow</code></a>, with preallocated output. If <code>out</code> and <code>img</code> have overlapping memory regions, behaviour is undefined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/mapwindow.jl#L107-L112">source</a></section></article><h2 id="Kernel"><a class="docs-heading-anchor" href="#Kernel">Kernel</a><a id="Kernel-1"></a><a class="docs-heading-anchor-permalink" href="#Kernel" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Kernel" href="#ImageFiltering.Kernel"><code>ImageFiltering.Kernel</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Kernel</code> is a module implementing filtering (correlation) kernels of full dimensionality. The following kernels are supported:</p><ul><li><code>sobel</code></li><li><code>prewitt</code></li><li><code>ando3</code>, <code>ando4</code>, and <code>ando5</code></li><li><code>scharr</code></li><li><code>bickley</code></li><li><code>gaussian</code></li><li><code>DoG</code> (Difference-of-Gaussian)</li><li><code>LoG</code> (Laplacian-of-Gaussian)</li><li><code>Laplacian</code></li><li><code>gabor</code></li><li><code>moffat</code></li></ul><p>See also: <a href="#KernelFactors"><code>KernelFactors</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernel.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Kernel.ando3" href="#ImageFiltering.Kernel.ando3"><code>ImageFiltering.Kernel.ando3</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    diff1, diff2 = ando3()</code></pre><p>Return <span>$3 \times 3$</span> correlation kernels for two-dimensional gradient compution using Ando&#39;s &quot;optimal&quot; filters. The <code>diff1</code> kernel computes the gradient along the y-axis (first dimension), and the <code>diff2</code> kernel computes the gradient along the x-axis (second dimension). <code>diff1 == rotr90(diff2)</code></p><pre><code class="language-julia hljs">    (diff,) = ando3(extended::NTuple{N,Bool}, d)</code></pre><p>Return (a tuple of) the N-dimensional correlation kernel for gradient compution along the dimension <code>d</code> using Ando&#39;s &quot;optimal&quot; filters of size 3. If <code>extended[dim]</code> is false, <code>diff</code> will have size 1 along that dimension.</p><p><strong>Citation</strong></p><p>S. Ando, &quot;Consistent gradient operators,&quot; <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, vol. 22, no.3, pp. 252–265, 2000. <a href="https://doi.org/doi:10.1109/34.841757">doi:10.1109/34.841757</a></p><p>See also: <a href="../../gradients/#KernelFactors.ando3"><code>KernelFactors.ando3</code></a>, <a href="#ImageFiltering.Kernel.ando4"><code>Kernel.ando4</code></a>, <a href="#ImageFiltering.Kernel.ando5"><code>Kernel.ando5</code></a> and  <a href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernel.jl#L105-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Kernel.ando4" href="#ImageFiltering.Kernel.ando4"><code>ImageFiltering.Kernel.ando4</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    diff1, diff2 = ando4()</code></pre><p>Return <span>$4 \times 4$</span> correlation  kernels for two-dimensional gradient compution using Ando&#39;s &quot;optimal&quot; filters.  The <code>diff1</code> kernel computes the gradient along the y-axis (first dimension), and  the <code>diff2</code> kernel computes the gradient along the x-axis (second dimension). <code>diff1 == rotr90(diff2)</code></p><pre><code class="language-julia hljs">    (diff,) = ando4(extended::NTuple{N,Bool}, d)</code></pre><p>Return (a tuple of) the N-dimensional correlation kernel for gradient compution along the dimension <code>d</code> using Ando&#39;s &quot;optimal&quot; filters of size 4. If <code>extended[dim]</code> is false, <code>diff</code> will have size 1 along that dimension.</p><p><strong>Citation</strong></p><p>S. Ando, &quot;Consistent gradient operators,&quot; <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, vol. 22, no.3, pp. 252–265, 2000. <a href="https://doi.org/doi:10.1109/34.841757">doi:10.1109/34.841757</a></p><p>See also: <a href="#ImageFiltering.KernelFactors.ando4"><code>KernelFactors.ando4</code></a>, <a href="#ImageFiltering.Kernel.ando3"><code>Kernel.ando3</code></a>, <a href="#ImageFiltering.Kernel.ando5"><code>Kernel.ando5</code></a> and <a href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernel.jl#L132-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Kernel.ando5" href="#ImageFiltering.Kernel.ando5"><code>ImageFiltering.Kernel.ando5</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    diff1, diff2 = ando5()</code></pre><p>Return <span>$5 \times 5$</span> correlation  kernels for two-dimensional gradient compution using Ando&#39;s &quot;optimal&quot; filters.  The <code>diff1</code> kernel computes the gradient along the y-axis (first dimension), and  the <code>diff2</code> kernel computes the gradient along the x-axis (second dimension). <code>diff1 == rotr90(diff2)</code></p><pre><code class="language-julia hljs">    (diff,) = ando5(extended::NTuple{N,Bool}, d)</code></pre><p>Return (a tuple of) the N-dimensional correlation kernel for gradient compution along the dimension <code>d</code> using Ando&#39;s &quot;optimal&quot; filters of size 5. If <code>extended[dim]</code> is false, <code>diff</code> will have size 1 along that dimension.</p><p><strong>Citation</strong></p><p>S. Ando, &quot;Consistent gradient operators,&quot; <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, vol. 22, no.3, pp. 252–265, 2000. <a href="https://doi.org/doi:10.1109/34.841757">doi:10.1109/34.841757</a></p><p>See also: <a href="#ImageFiltering.KernelFactors.ando5"><code>KernelFactors.ando5</code></a>, <a href="#ImageFiltering.Kernel.ando3"><code>Kernel.ando3</code></a>, <a href="#ImageFiltering.Kernel.ando4"><code>Kernel.ando4</code></a> and  <a href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernel.jl#L168-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Kernel.bickley" href="#ImageFiltering.Kernel.bickley"><code>ImageFiltering.Kernel.bickley</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    diff1, diff2 = bickley()</code></pre><p>Return <span>$3 \times 3$</span> correlation kernels for two-dimensional gradient compution using the Bickley operator. The <code>diff1</code> kernel computes the gradient along the y-axis (first dimension), and the <code>diff2</code> kernel computes the gradient along the x-axis (second dimension). <code>diff1 == rotr90(diff2)</code></p><pre><code class="language-julia hljs">    (diff,) = bickley(extended::NTuple{N,Bool}, d)</code></pre><p>Return (a tuple of) the N-dimensional correlation kernel for gradient compution along the dimension <code>d</code> using the Bickley operator. If <code>extended[dim]</code> is false, <code>diff</code> will have size 1 along that dimension.</p><p><strong>Citation</strong></p><p>W. G. Bickley, &quot;Finite difference formulae for the square lattice,&quot; <em>The Quarterly Journal of Mechanics and Applied Mathematics</em>, vol. 1, no. 1, pp. 35–42, 1948.  <a href="https://doi.org/doi:10.1137/12087092x">doi:10.1093/qjmam/1.1.35</a></p><p>See also: <a href="../../gradients/#KernelFactors.bickley"><code>KernelFactors.bickley</code></a>, <a href="#ImageFiltering.Kernel.prewitt"><code>Kernel.prewitt</code></a>, <a href="#ImageFiltering.Kernel.ando3"><code>Kernel.ando3</code></a>,  <a href="#ImageFiltering.Kernel.scharr"><code>Kernel.scharr</code></a> and <a href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernel.jl#L233-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Kernel.DoG" href="#ImageFiltering.Kernel.DoG"><code>ImageFiltering.Kernel.DoG</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DoG((σp1, σp2, ...), (σm1, σm2, ...), [l1, l2, ...]) -&gt; k
DoG((σ1, σ2, ...))                                   -&gt; k
DoG(σ::Real)                                         -&gt; k</code></pre><p>Construct a multidimensional difference-of-gaussian kernel <code>k</code>, equal to <code>gaussian(σp, l)-gaussian(σm, l)</code>.  When only a single <code>σ</code> is supplied, the default is to choose <code>σp = σ, σm = √2 σ</code>. Optionally provide the kernel length <code>l</code>; the default is to extend by two <code>max(σp,σm)</code> in each direction from the center. <code>l</code> must be odd.</p><p>If <code>σ</code> is provided as a single number, a symmetric 2d DoG kernel is returned.</p><p>See also: <a href="#ImageFiltering.KernelFactors.IIRGaussian"><code>KernelFactors.IIRGaussian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernel.jl#L289-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Kernel.gabor" href="#ImageFiltering.Kernel.gabor"><code>ImageFiltering.Kernel.gabor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gabor(size_x,size_y,σ,θ,λ,γ,ψ) -&gt; (k_real,k_complex)</code></pre><p>Returns a 2 Dimensional Complex Gabor kernel contained in a tuple where</p><ul><li><code>size_x</code>, <code>size_y</code> denote the size of the kernel</li><li><code>σ</code> denotes the standard deviation of the Gaussian envelope</li><li><code>θ</code> represents the orientation of the normal to the parallel stripes of a Gabor function</li><li><code>λ</code> represents the wavelength of the sinusoidal factor</li><li><code>γ</code> is the spatial aspect ratio, and specifies the ellipticity of the support of the Gabor function</li><li><code>ψ</code> is the phase offset</li></ul><p>#Citation N. Petkov and P. Kruizinga, “Computational models of visual neurons specialised in the detection of periodic and aperiodic oriented visual stimuli: bar and grating cells,” Biological Cybernetics, vol. 76, no. 2, pp. 83–96, Feb. 1997. doi.org/10.1007/s004220050323</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernel.jl#L428-L442">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Kernel.gaussian" href="#ImageFiltering.Kernel.gaussian"><code>ImageFiltering.Kernel.gaussian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gaussian((σ1, σ2, ...), [(l1, l2, ...)]) -&gt; g
gaussian(σ)                  -&gt; g</code></pre><p>Construct a multidimensional gaussian filter, with standard deviation <code>σd</code> along dimension <code>d</code>. Optionally provide the kernel length <code>l</code>, which must be a tuple of the same length.</p><p>If <code>σ</code> is supplied as a single number, a symmetric 2d kernel is constructed.</p><p>See also: <a href="#ImageFiltering.KernelFactors.gaussian"><code>KernelFactors.gaussian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernel.jl#L262-L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Kernel.Laplacian" href="#ImageFiltering.Kernel.Laplacian"><code>ImageFiltering.Kernel.Laplacian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Laplacian((true,true,false,...))
Laplacian(dims, N)
Laplacian()</code></pre><p>Laplacian kernel in <code>N</code> dimensions, taking derivatives along the directions marked as <code>true</code> in the supplied tuple. Alternatively, one can pass <code>dims</code>, a listing of the dimensions for differentiation. (However, this variant is not inferrable.)</p><p><code>Laplacian()</code> is the 2d laplacian, equivalent to <code>Laplacian((true,true))</code>.</p><p>The kernel is represented as an opaque type, but you can use <code>convert(AbstractArray, L)</code> to convert it into array format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernel.jl#L357-L371">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Kernel.LoG" href="#ImageFiltering.Kernel.LoG"><code>ImageFiltering.Kernel.LoG</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LoG((σ1, σ2, ...)) -&gt; k
LoG(σ)             -&gt; k</code></pre><p>Construct a Laplacian-of-Gaussian kernel <code>k</code>. <code>σd</code> is the gaussian width along dimension <code>d</code>.  If <code>σ</code> is supplied as a single number, a symmetric 2d kernel is returned.</p><p>See also: <a href="#ImageFiltering.KernelFactors.IIRGaussian"><code>KernelFactors.IIRGaussian</code></a> and <a href="#ImageFiltering.Kernel.Laplacian"><code>Kernel.Laplacian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernel.jl#L315-L324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Kernel.moffat" href="#ImageFiltering.Kernel.moffat"><code>ImageFiltering.Kernel.moffat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">moffat(α, β, ls) -&gt; k</code></pre><p>Constructs a 2D, symmetric Moffat kernel <code>k</code> with core width, <code>α</code>, and power, <code>β</code>. Size of kernel defaults to 4 * full-width-half-max or as specified in <code>ls</code>. See <a href="https://nbviewer.jupyter.org/github/ysbach/AO_2017/blob/master/04_Ground_Based_Concept.ipynb#1.2.-Moffat">this notebook</a> for details.</p><p><strong>Citation</strong></p><p>Moffat, A. F. J. &quot;A theoretical investigation of focal stellar images in the photographic emulsion and application to photographic photometry.&quot; Astronomy and Astrophysics 3 (1969): 455.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernel.jl#L488-L497">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Kernel.prewitt" href="#ImageFiltering.Kernel.prewitt"><code>ImageFiltering.Kernel.prewitt</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    diff1, diff2 = prewitt()</code></pre><p>Return <span>$3 \times 3$</span> correlation kernels for two-dimensional gradient compution using the Prewitt operator. The <code>diff1</code> kernel computes the gradient along the y-axis (first dimension), and the <code>diff2</code> kernel computes the gradient along the x-axis (second dimension). <code>diff1 == rotr90(diff2)</code></p><pre><code class="language-julia hljs">    (diff,) = prewitt(extended::NTuple{N,Bool}, d)</code></pre><p>Return (a tuple of) the N-dimensional correlation kernel for gradient compution along the dimension <code>d</code> using the Prewitt operator. If <code>extended[dim]</code> is false, <code>diff</code> will have size 1 along that dimension.</p><p><strong>Citation</strong></p><p>J. M. Prewitt, &quot;Object enhancement and extraction,&quot; <em>Picture processing and Psychopictorics</em>, vol. 10, no. 1, pp. 15–19, 1970.</p><p>See also: <a href="../../gradients/#KernelFactors.prewitt"><code>KernelFactors.prewitt</code></a>, <a href="#ImageFiltering.Kernel.sobel"><code>Kernel.sobel</code></a>, <a href="#ImageFiltering.Kernel.ando3"><code>Kernel.ando3</code></a>, <a href="#ImageFiltering.Kernel.scharr"><code>Kernel.scharr</code></a>,<a href="#ImageFiltering.Kernel.bickley"><code>Kernel.bickley</code></a> and <a href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernel.jl#L77-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Kernel.scharr" href="#ImageFiltering.Kernel.scharr"><code>ImageFiltering.Kernel.scharr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    diff1, diff2 = scharr()</code></pre><p>Return <span>$3 \times 3$</span> correlation kernels for two-dimensional gradient compution using the Scharr operator. The <code>diff1</code> kernel computes the gradient along the y-axis (first dimension), and the <code>diff2</code> kernel  computes the gradient along the x-axis (second dimension). <code>diff1 == rotr90(diff2)</code></p><pre><code class="language-julia hljs">    (diff,) = scharr(extended::NTuple{N,Bool}, d)</code></pre><p>Return (a tuple of) the N-dimensional correlation kernel for gradient compution along the dimension <code>d</code> using the Scharr operator. If <code>extended[dim]</code> is false, <code>diff</code> will have size 1 along that dimension.</p><p><strong>Citation</strong></p><p>H. Scharr and  J. Weickert, &quot;An anisotropic diffusion algorithm with optimized rotation invariance,&quot; <em>Mustererkennung 2000</em>, pp. 460–467, 2000. <a href="https://doi.org/doi:10.1007/978-3-642-59802-9_58">doi:10.1007/978-3-642-59802-9_58</a></p><p>See also: <a href="../../gradients/#KernelFactors.scharr"><code>KernelFactors.scharr</code></a>, <a href="#ImageFiltering.Kernel.prewitt"><code>Kernel.prewitt</code></a>, <a href="#ImageFiltering.Kernel.ando3"><code>Kernel.ando3</code></a>, <a href="#ImageFiltering.Kernel.bickley"><code>Kernel.bickley</code></a> and <a href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernel.jl#L205-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Kernel.sobel" href="#ImageFiltering.Kernel.sobel"><code>ImageFiltering.Kernel.sobel</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    diff1, diff2 = sobel()</code></pre><p>Return <span>$3 \times 3$</span> correlation kernels for two-dimensional gradient compution using the Sobel operator. The <code>diff1</code> kernel computes the gradient along the y-axis (first dimension), and the <code>diff2</code> kernel computes the gradient along the x-axis (second dimension). <code>diff1 == rotr90(diff2)</code></p><pre><code class="language-julia hljs">    (diff,) = sobel(extended::NTuple{N,Bool}, d)</code></pre><p>Return (a tuple of) the N-dimensional correlation kernel for gradient compution along the dimension <code>d</code> using the Sobel operator. If <code>extended[dim]</code> is false, <code>diff</code> will have size 1 along that dimension.</p><p><strong>Citation</strong></p><p>P.-E. Danielsson and O. Seger, &quot;Generalized and separable sobel operators,&quot; in  <em>Machine Vision for Three-Dimensional Scenes</em>,  H. Freeman, Ed.  Academic Press, 1990,  pp. 347–379. <a href="https://doi.org/doi:10.1016/b978-0-12-266722-0.50016-6">doi:10.1016/b978-0-12-266722-0.50016-6</a></p><p>See also: <a href="../../gradients/#KernelFactors.sobel"><code>KernelFactors.sobel</code></a>, <a href="#ImageFiltering.Kernel.prewitt"><code>Kernel.prewitt</code></a>, <a href="#ImageFiltering.Kernel.ando3"><code>Kernel.ando3</code></a>, <a href="#ImageFiltering.Kernel.scharr"><code>Kernel.scharr</code></a>, <a href="#ImageFiltering.Kernel.bickley"><code>Kernel.bickley</code></a> and <a href="#ImageFiltering.imgradients"><code>imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernel.jl#L48-L72">source</a></section></article><h2 id="KernelFactors"><a class="docs-heading-anchor" href="#KernelFactors">KernelFactors</a><a id="KernelFactors-1"></a><a class="docs-heading-anchor-permalink" href="#KernelFactors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.KernelFactors" href="#ImageFiltering.KernelFactors"><code>ImageFiltering.KernelFactors</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>KernelFactors</code> is a module implementing separable filtering kernels, each stored in terms of their factors. The following kernels are supported:</p><ul><li><code>box</code></li><li><code>sobel</code></li><li><code>prewitt</code></li><li><code>ando3</code>, <code>ando4</code>, and <code>ando5</code> (the latter in 2d only)</li><li><code>scharr</code></li><li><code>bickley</code></li><li><code>gaussian</code></li><li><code>IIRGaussian</code> (approximate gaussian filtering, fast even for large σ)</li></ul><p>See also: <a href="#Kernel"><code>Kernel</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.KernelFactors.ando3" href="#ImageFiltering.KernelFactors.ando3"><code>ImageFiltering.KernelFactors.ando3</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    kern1, kern2 = ando3()</code></pre><p>Return a factored form of Ando&#39;s &quot;optimal&quot; <span>$3 \times 3$</span> gradient filters for dimensions 1 and 2 of your image.</p><p><strong>Citation</strong></p><p>S. Ando, &quot;Consistent gradient operators,&quot; <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, vol. 22, no.3, pp. 252–265, 2000. <a href="https://doi.org/doi:10.1109/34.841757">doi:10.1109/34.841757</a></p><p>See also: <a href="#ImageFiltering.Kernel.ando3"><code>Kernel.ando3</code></a>,<a href="#ImageFiltering.KernelFactors.ando4"><code>KernelFactors.ando4</code></a>, <a href="#ImageFiltering.KernelFactors.ando5"><code>KernelFactors.ando5</code></a> and <a href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L323-L334">source</a></section><section><div><pre><code class="language-julia hljs">    kern = ando3(extended::NTuple{N,Bool}, d)</code></pre><p>Return a factored Ando filter (size 3) for computing the gradient in <code>N</code> dimensions along axis <code>d</code>.  If <code>extended[dim]</code> is false, <code>kern</code> will have size 1 along that dimension.</p><p>See also: <a href="#ImageFiltering.KernelFactors.ando4"><code>KernelFactors.ando4</code></a>, <a href="#ImageFiltering.KernelFactors.ando5"><code>KernelFactors.ando5</code></a> and <a href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L341-L351">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.KernelFactors.ando4" href="#ImageFiltering.KernelFactors.ando4"><code>ImageFiltering.KernelFactors.ando4</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    kern1, kern2 = ando4()</code></pre><p>Return separable approximations of Ando&#39;s &quot;optimal&quot; 4x4 filters for dimensions 1 and 2 of your image.</p><p><strong>Citation</strong></p><p>S. Ando, &quot;Consistent gradient operators,&quot; <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, vol. 22, no.3, pp. 252–265, 2000. <a href="https://doi.org/doi:10.1109/34.841757">doi:10.1109/34.841757</a></p><p>See also: <a href="#ImageFiltering.Kernel.ando4"><code>Kernel.ando4</code></a> and <a href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L356-L367">source</a></section><section><div><pre><code class="language-julia hljs">    kern = ando4(extended::NTuple{N,Bool}, d)</code></pre><p>Return a factored Ando filter (size 4) for computing the gradient in <code>N</code> dimensions along axis <code>d</code>.  If <code>extended[dim]</code> is false, <code>kern</code> will have size 1 along that dimension.</p><p><strong>Citation</strong></p><p>S. Ando, &quot;Consistent gradient operators,&quot; <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, vol. 22, no.3, pp. 252–265, 2000. <a href="https://doi.org/doi:10.1109/34.841757">doi:10.1109/34.841757</a></p><p>See also: <a href="#ImageFiltering.Kernel.ando4"><code>Kernel.ando4</code></a> and <a href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L374-L386">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.KernelFactors.ando5" href="#ImageFiltering.KernelFactors.ando5"><code>ImageFiltering.KernelFactors.ando5</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    kern1, kern2 = ando5()</code></pre><p>Return a separable approximations of Ando&#39;s &quot;optimal&quot; 5x5 gradient filters for dimensions 1 and 2 of your image.</p><p><strong>Citation</strong></p><p>S. Ando, &quot;Consistent gradient operators,&quot; <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, vol. 22, no.3, pp. 252–265, 2000. <a href="https://doi.org/doi:10.1109/34.841757">doi:10.1109/34.841757</a></p><p>See also: <a href="#ImageFiltering.Kernel.ando5"><code>Kernel.ando5</code></a> and <a href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L395-L406">source</a></section><section><div><pre><code class="language-julia hljs">    kern = ando5(extended::NTuple{N,Bool}, d)</code></pre><p>Return a factored Ando filter (size 5) for computing the gradient in <code>N</code> dimensions along axis <code>d</code>.  If <code>extended[dim]</code> is false, <code>kern</code> will have size 1 along that dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L413-L420">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.KernelFactors.bickley" href="#ImageFiltering.KernelFactors.bickley"><code>ImageFiltering.KernelFactors.bickley</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    kern1, kern2 = bickley()</code></pre><p>Return factored Bickley filters for dimensions 1 and 2 of your image.  Each is a 2-tuple of one-dimensional filters.</p><p><strong>Citation</strong></p><p>W. G. Bickley, &quot;Finite difference formulae for the square lattice,&quot; <em>The Quarterly Journal of Mechanics and Applied Mathematics</em>, vol. 1, no. 1, pp. 35–42, 1948.  <a href="https://doi.org/doi:10.1137/12087092x">doi:10.1093/qjmam/1.1.35</a></p><p>See also: <a href="#ImageFiltering.Kernel.bickley"><code>Kernel.bickley</code></a> and <a href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L280-L291">source</a></section><section><div><pre><code class="language-julia hljs">    kern = bickley(extended::NTuple{N,Bool}, d)</code></pre><p>Return a factored Bickley filter for computing the gradient in <code>N</code> dimensions along axis <code>d</code>. If <code>extended[dim]</code> is false, <code>kern</code> will have size 1 along that dimension.</p><p>See also: <a href="#ImageFiltering.Kernel.bickley"><code>Kernel.bickley</code></a> and <a href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L298-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.KernelFactors.gaussian" href="#ImageFiltering.KernelFactors.gaussian"><code>ImageFiltering.KernelFactors.gaussian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gaussian(σ::Real, [l]) -&gt; g</code></pre><p>Construct a 1d gaussian kernel <code>g</code> with standard deviation <code>σ</code>, optionally providing the kernel length <code>l</code>. The default is to extend by two <code>σ</code> in each direction from the center. <code>l</code> must be odd.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L431-L437">source</a></section><section><div><pre><code class="language-julia hljs">gaussian((σ1, σ2, ...), [l]) -&gt; (g1, g2, ...)</code></pre><p>Construct a multidimensional gaussian filter as a product of single-dimension factors, with standard deviation <code>σd</code> along dimension <code>d</code>. Optionally provide the kernel length <code>l</code>, which must be a tuple of the same length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L446-L453">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.KernelFactors.IIRGaussian" href="#ImageFiltering.KernelFactors.IIRGaussian"><code>ImageFiltering.KernelFactors.IIRGaussian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IIRGaussian([T], σ; emit_warning::Bool=true)</code></pre><p>Construct an infinite impulse response (IIR) approximation to a Gaussian of standard deviation <code>σ</code>. <code>σ</code> may either be a single real number or a tuple of numbers; in the latter case, a tuple of such filters will be created, each for filtering a different dimension of an array.</p><p>Optionally specify the type <code>T</code> for the filter coefficients; if not supplied, it will match <code>σ</code> (unless <code>σ</code> is not floating-point, in which case <code>Float64</code> will be chosen).</p><p><strong>Citation</strong></p><p>I. T. Young, L. J. van Vliet, and M. van Ginkel, &quot;Recursive Gabor Filtering&quot;. IEEE Trans. Sig. Proc., 50: 2798-2805 (2002).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L516-L532">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.KernelFactors.prewitt" href="#ImageFiltering.KernelFactors.prewitt"><code>ImageFiltering.KernelFactors.prewitt</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    kern1, kern2 = prewitt()</code></pre><p>Return factored Prewitt filters for dimensions 1 and 2 of your image. Each is a 2-tuple of one-dimensional filters.</p><p><strong>Citation</strong></p><p>J. M. Prewitt, &quot;Object enhancement and extraction,&quot; <em>Picture processing and Psychopictorics</em>, vol. 10, no. 1, pp. 15–19, 1970.</p><p>See also: <a href="#ImageFiltering.Kernel.prewitt"><code>Kernel.prewitt</code></a> and <a href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L212-L223">source</a></section><section><div><pre><code class="language-julia hljs">    kern = prewitt(extended::NTuple{N,Bool}, d)</code></pre><p>Return a factored Prewitt filter for computing the gradient in <code>N</code> dimensions along axis <code>d</code>. If <code>extended[dim]</code> is false, <code>kern</code> will have size 1 along that dimension.</p><p>See also: <a href="#ImageFiltering.Kernel.prewitt"><code>Kernel.prewitt</code></a> and <a href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L230-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.KernelFactors.scharr" href="#ImageFiltering.KernelFactors.scharr"><code>ImageFiltering.KernelFactors.scharr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    kern1, kern2 = scharr()</code></pre><p>Return factored Scharr filters for dimensions 1 and 2 of your image.  Each is a 2-tuple of one-dimensional filters.</p><p><strong>Citation</strong></p><p>H. Scharr and  J. Weickert, &quot;An anisotropic diffusion algorithm with optimized rotation invariance,&quot; <em>Mustererkennung 2000</em>, pp. 460–467, 2000. <a href="https://doi.org/doi:10.1007/978-3-642-59802-9_58">doi:10.1007/978-3-642-59802-9_58</a></p><p>See also: <a href="#ImageFiltering.Kernel.scharr"><code>Kernel.scharr</code></a> and <a href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L245-L257">source</a></section><section><div><pre><code class="language-julia hljs">    kern = scharr(extended::NTuple{N,Bool}, d)</code></pre><p>Return a factored Scharr filter for computing the gradient in <code>N</code> dimensions along axis <code>d</code>. If <code>extended[dim]</code> is false, <code>kern</code> will have size 1 along that dimension.</p><p>See also: <a href="#ImageFiltering.Kernel.scharr"><code>Kernel.scharr</code></a> and <a href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L264-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.KernelFactors.sobel" href="#ImageFiltering.KernelFactors.sobel"><code>ImageFiltering.KernelFactors.sobel</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    kern1, kern2 = sobel()</code></pre><p>Return factored  Sobel filters for dimensions 1 and 2 of a two-dimensional image. Each is a 2-tuple of one-dimensional filters.</p><p><strong>Citation</strong></p><p>P.-E. Danielsson and O. Seger, &quot;Generalized and separable sobel operators,&quot; in  <em>Machine Vision for Three-Dimensional Scenes</em>,  H. Freeman, Ed.  Academic Press, 1990,  pp. 347–379. <a href="https://doi.org/doi:10.1016/b978-0-12-266722-0.50016-6">doi:10.1016/b978-0-12-266722-0.50016-6</a></p><p>See also: <a href="#ImageFiltering.Kernel.sobel"><code>Kernel.sobel</code></a>  and <a href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L180-L191">source</a></section><section><div><pre><code class="language-julia hljs">    kern = sobel(extended::NTuple{N,Bool}, d)</code></pre><p>Return a factored Sobel filter for computing the gradient in <code>N</code> dimensions along axis <code>d</code>. If <code>extended[dim]</code> is false, <code>kern</code> will have size 1 along that dimension.</p><p>See also: <a href="#ImageFiltering.Kernel.sobel"><code>Kernel.sobel</code></a> and <a href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L198-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.KernelFactors.TriggsSdika" href="#ImageFiltering.KernelFactors.TriggsSdika"><code>ImageFiltering.KernelFactors.TriggsSdika</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TriggsSdika(a, b, scale, M)</code></pre><p>Defines a kernel for one-dimensional infinite impulse response (IIR) filtering. <code>a</code> is a &quot;forward&quot; filter, <code>b</code> a &quot;backward&quot; filter, <code>M</code> is a matrix for matching boundary conditions at the right edge, and <code>scale</code> is a constant scaling applied to each element at the conclusion of filtering.</p><p><strong>Citation</strong></p><p>B. Triggs and M. Sdika, &quot;Boundary conditions for Young-van Vliet recursive filtering&quot;. IEEE Trans. on Sig. Proc. 54: 2365-2367 (2006).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L474-L488">source</a></section><section><div><pre><code class="language-julia hljs">TriggsSdika(ab, scale)</code></pre><p>Create a symmetric Triggs-Sdika filter (with <code>a = b = ab</code>). <code>M</code> is calculated for you. Only length 3 filters are currently supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L491-L496">source</a></section></article><h2 id="Kernel-utilities"><a class="docs-heading-anchor" href="#Kernel-utilities">Kernel utilities</a><a id="Kernel-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Kernel-utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OffsetArrays.center" href="#OffsetArrays.center"><code>OffsetArrays.center</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">center(A, [r::RoundingMode=RoundDown])::Dims</code></pre><p>Return the center coordinate of given array <code>A</code>. If <code>size(A, k)</code> is even, a rounding procedure will be applied with mode <code>r</code>.</p><div class="admonition is-compat"><header class="admonition-header">OffsetArrays 1.9</header><div class="admonition-body"><p>This method requires at least OffsetArrays 1.9.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(collect(1:9), 3, 3)
3×3 Matrix{Int64}:
 1  4  7
 2  5  8
 3  6  9

julia&gt; c = OffsetArrays.center(A)
(2, 2)

julia&gt; A[c...]
5

julia&gt; Ao = OffsetArray(A, -2, -2); # axes (-1:1, -1:1)

julia&gt; c = OffsetArrays.center(Ao)
(0, 0)

julia&gt; Ao[c...]
5</code></pre><p>To shift the center coordinate of the given array to <code>(0, 0, ...)</code>, you can use <a href="#OffsetArrays.centered"><code>centered</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/OffsetArrays.jl/blob/v1.17.0/src/OffsetArrays.jl#L763-L798">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OffsetArrays.centered" href="#OffsetArrays.centered"><code>OffsetArrays.centered</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">centered(A, cp=center(A)) -&gt; Ao</code></pre><p>Shift the center coordinate/point <code>cp</code> of array <code>A</code> to <code>(0, 0, ..., 0)</code>. Internally, this is equivalent to <code>OffsetArray(A, .-cp)</code>.</p><div class="admonition is-compat"><header class="admonition-header">OffsetArrays 1.9</header><div class="admonition-body"><p>This method requires at least OffsetArrays 1.9.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(collect(1:9), 3, 3)
3×3 Matrix{Int64}:
 1  4  7
 2  5  8
 3  6  9

julia&gt; Ao = OffsetArrays.centered(A); # axes (-1:1, -1:1)

julia&gt; Ao[0, 0]
5

julia&gt; Ao = OffsetArray(A, OffsetArrays.Origin(0)); # axes (0:2, 0:2)

julia&gt; Aoo = OffsetArrays.centered(Ao); # axes (-1:1, -1:1)

julia&gt; Aoo[0, 0]
5</code></pre><p>Users are allowed to pass <code>cp</code> to change how &quot;center point&quot; is interpreted, but the meaning of the output array should be reinterpreted as well. For instance, if <code>cp = map(last, axes(A))</code> then this function no longer shifts the center point but instead the bottom-right point to <code>(0, 0, ..., 0)</code>. A commonly usage of <code>cp</code> is to change the rounding behavior when the array is of even size at some dimension:</p><pre><code class="language-julia-repl hljs">julia&gt; A = reshape(collect(1:4), 2, 2) # Ideally the center should be (1.5, 1.5) but OffsetArrays only support integer offsets
2×2 Matrix{Int64}:
 1  3
 2  4

julia&gt; OffsetArrays.centered(A, OffsetArrays.center(A, RoundUp)) # set (2, 2) as the center point
2×2 OffsetArray(::Matrix{Int64}, -1:0, -1:0) with eltype Int64 with indices -1:0×-1:0:
 1  3
 2  4

julia&gt; OffsetArrays.centered(A, OffsetArrays.center(A, RoundDown)) # set (1, 1) as the center point
2×2 OffsetArray(::Matrix{Int64}, 0:1, 0:1) with eltype Int64 with indices 0:1×0:1:
 1  3
 2  4</code></pre><p>See also <a href="#OffsetArrays.center"><code>center</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaArrays/OffsetArrays.jl/blob/v1.17.0/src/OffsetArrays.jl#L805-L860">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.KernelFactors.kernelfactors" href="#ImageFiltering.KernelFactors.kernelfactors"><code>ImageFiltering.KernelFactors.kernelfactors</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kernelfactors(factors::Tuple)</code></pre><p>Prepare a factored kernel for filtering. If passed a 2-tuple of vectors of lengths <code>m</code> and <code>n</code>, this will return a 2-tuple of <code>ReshapedVector</code>s that are effectively of sizes <code>m×1</code> and <code>1×n</code>. In general, each successive <code>factor</code> will be reshaped to extend along the corresponding dimension.</p><p>If passed a tuple of general arrays, it is assumed that each is shaped appropriately along its &quot;leading&quot; dimensions; the dimensionality of each is &quot;extended&quot; to <code>N = length(factors)</code>, appending 1s to the size as needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L573-L585">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Kernel.reflect" href="#ImageFiltering.Kernel.reflect"><code>ImageFiltering.Kernel.reflect</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reflect(kernel) --&gt; reflectedkernel</code></pre><p>Compute the pointwise reflection around 0, 0, ... of the kernel <code>kernel</code>.  Using <code>imfilter</code> with a <code>reflectedkernel</code> performs convolution, rather than correlation, with respect to the original <code>kernel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernel.jl#L513-L519">source</a></section></article><h2 id="Boundaries-and-padding"><a class="docs-heading-anchor" href="#Boundaries-and-padding">Boundaries and padding</a><a id="Boundaries-and-padding-1"></a><a class="docs-heading-anchor-permalink" href="#Boundaries-and-padding" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.BorderArray" href="#ImageFiltering.BorderArray"><code>ImageFiltering.BorderArray</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BorderArray(inner::AbstractArray, border::AbstractBorder) &lt;: AbstractArray</code></pre><p>Construct a thin wrapper around the array <code>inner</code>, with given <code>border</code>. No data is copied in the constructor, instead border values are computed on the fly in <code>getindex</code> calls. Useful for stencil computations. See also <a href="#ImageFiltering.padarray"><code>padarray</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using ImageFiltering

julia&gt; arr = reshape(1:6, (2,3))
2×3 reshape(::UnitRange{Int64}, 2, 3) with eltype Int64:
 1  3  5
 2  4  6

julia&gt; BorderArray(arr, Pad((1,1)))
BorderArray{Int64,2,Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}},Pad{2}} with indices 0:3×0:4:
 1  1  3  5  5
 1  1  3  5  5
 2  2  4  6  6
 2  2  4  6  6

julia&gt; BorderArray(arr, Fill(10, (2,1)))
BorderArray{Int64,2,Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}},Fill{Int64,2}} with indices -1:4×0:4:
 10  10  10  10  10
 10  10  10  10  10
 10   1   3   5  10
 10   2   4   6  10
 10  10  10  10  10
 10  10  10  10  10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/borderarray.jl#L26-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Fill" href="#ImageFiltering.Fill"><code>ImageFiltering.Fill</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Fill{T,N} &lt;: AbstractBorder
    value::T
    lo::Dims{N}
    hi::Dims{N}
end</code></pre><p><code>Fill</code> is a type that designates a particular value which will be used to extrapolate pixels beyond the boundary of an image.</p><p><strong>Output</strong></p><p>The type <code>Fill</code> specifying the value with which the boundary of the image should be padded.</p><p><strong>Details</strong></p><p>When representing a two-dimensional spatial image filtering operation as a discrete convolution between an image and a <span>$D \times D$</span> filter, the results are undefined for pixels closer than <span>$D$</span> pixels from the border of the image. To define the operation near and at the border, you need a scheme for extrapolating pixels beyond the edge. The <code>Fill</code> type allows you to specify a particular value which will be used in the extrapolation. For more elaborate extrapolation schemes, see <a href="#ImageFiltering.Pad"><code>Pad</code></a>.</p><p>The type facilitates the padding of one, two, or multi-dimensional images.</p><p>You can specify a different amount of padding at the lower and upper borders of each dimension of the image (top, left, bottom, and right in two dimensions).</p><p><strong>Example</strong></p><p>To illustrate this, consider an image consisting of a row of six pixels which are specified alphabetically:</p><pre><code class="language-plain hljs">    ┏━━━━━━┓ 
    ┃abcdef┃ 
    ┗━━━━━━┛ </code></pre><p>Padding with a constant value <code>m</code> only on the left and right border looks like this:</p><pre><code class="language-plain hljs">╭────┏━━━━━━┓────╮
│mmmm┃abcdef┃mmmm│
╰────┗━━━━━━┛────╯</code></pre><p>(Analogous consequences hold for the top and bottom border.)</p><p>See also: <a href="#ImageFiltering.Pad"><code>Pad</code></a>, <a href="#ImageFiltering.padarray"><code>padarray</code></a>, <a href="#ImageFiltering.Inner"><code>Inner</code></a> and <a href="#ImageFiltering.NoPad"><code>NoPad</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/border.jl#L407-L464">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Inner" href="#ImageFiltering.Inner"><code>ImageFiltering.Inner</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Inner()
Inner(lo, hi)</code></pre><p>Indicate that edges are to be discarded in filtering, only the interior of the result is to be returned.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">imfilter(img, kernel, Inner())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/border.jl#L358-L367">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.NA" href="#ImageFiltering.NA"><code>ImageFiltering.NA</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NA(na=isnan)</code></pre><p>Choose filtering using &quot;NA&quot; (Not Available) boundary conditions. This is most appropriate for filters that have only positive weights, such as blurring filters. Effectively, the output value is normalized in the following way:</p><pre><code class="nohighlight hljs">          filtered array with Fill(0) boundary conditions
output =  -----------------------------------------------
          filtered 1     with Fill(0) boundary conditions</code></pre><p>Array elements for which <code>na</code> returns <code>true</code> are also considered outside array boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/border.jl#L388-L402">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.NoPad" href="#ImageFiltering.NoPad"><code>ImageFiltering.NoPad</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoPad()
NoPad(border)</code></pre><p>Indicates that no padding should be applied to the input array, or that you have already pre-padded the input image. Passing a <code>border</code> object allows you to preserve &quot;memory&quot; of a border choice; it can be retrieved by indexing with <code>[]</code>.</p><p><strong>Example</strong></p><p>The commands</p><pre><code class="nohighlight hljs">np = NoPad(Pad(:replicate))
imfilter!(out, img, kernel, np)</code></pre><p>run filtering directly, skipping any padding steps.  Every entry of <code>out</code> must be computable using in-bounds operations on <code>img</code> and <code>kernel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/border.jl#L12-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Pad" href="#ImageFiltering.Pad"><code>ImageFiltering.Pad</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    struct Pad{N} &lt;: AbstractBorder
        style::Symbol
        lo::Dims{N}    # number to extend by on the lower edge for each dimension
        hi::Dims{N}    # number to extend by on the upper edge for each dimension
    end</code></pre><p><code>Pad</code> is a type that designates the form of padding which should be used to extrapolate pixels beyond the boundary of an image. Instances must set <code>style</code>, a Symbol specifying the boundary conditions of the image.</p><p><strong>Output</strong></p><p>The type <code>Pad</code> specifying how the boundary of an image should be padded.</p><p><strong>Extended help</strong></p><p>When representing a spatial two-dimensional image filtering operation as a discrete convolution between the image and a <span>$D \times D$</span> filter, the results are undefined for pixels closer than <span>$D$</span> pixels from the border of the image. To define the operation near and at the border, one needs a scheme for extrapolating pixels beyond the edge. The <code>Pad</code> type allows one to specify the necessary extrapolation scheme.</p><p>The type facilitates the padding of one, two or multi-dimensional images.</p><p>You can specify a different amount of padding at the lower and upper borders of each dimension of the image (top, left, bottom and right in two dimensions).</p><p><strong>Options</strong></p><p>Some valid <code>style</code> options are described below. As an indicative example of each option the results of the padding are illustrated on an image consisting of a row of six pixels which are specified alphabetically:</p><pre><code class="language-plain hljs">        ┏━━━━━━┓ 
        ┃abcdef┃ 
        ┗━━━━━━┛ </code></pre><p>We show the effects of padding only on the left and right border, but analogous consequences hold for the top and bottom border.</p><p><strong><code>:replicate</code> (Default)</strong></p><p>The border pixels extend beyond the image boundaries.</p><pre><code class="language-plain hljs">   ╭────┏━━━━━━┓────╮
   │aaaa┃abcdef┃ffff│
   ╰────┗━━━━━━┛────╯</code></pre><p>See also: <a href="#ImageFiltering.Fill"><code>Fill</code></a>, <a href="#ImageFiltering.padarray"><code>padarray</code></a>, <a href="#ImageFiltering.Inner"><code>Inner</code></a> and <a href="#ImageFiltering.NoPad"><code>NoPad</code></a></p><p><strong><code>:circular</code></strong></p><p>The border pixels wrap around. For instance, indexing beyond the left border returns values starting from the right border.</p><pre><code class="language-plain hljs">
   ╭────┏━━━━━━┓────╮
   │cdef┃abcdef┃abcd│
   ╰────┗━━━━━━┛────╯
</code></pre><p>See also: <a href="#ImageFiltering.Fill"><code>Fill</code></a>, <a href="#ImageFiltering.padarray"><code>padarray</code></a>, <a href="#ImageFiltering.Inner"><code>Inner</code></a> and <a href="#ImageFiltering.NoPad"><code>NoPad</code></a></p><p><strong><code>:symmetric</code></strong></p><p>The border pixels reflect relative to a position between pixels. That is, the border pixel is omitted when mirroring.</p><pre><code class="language-plain hljs">
   ╭────┏━━━━━━┓────╮
   │edcb┃abcdef┃edcb│
   ╰────┗━━━━━━┛────╯
</code></pre><p><strong><code>:reflect</code></strong></p><p>The border pixels reflect relative to the edge itself.</p><pre><code class="language-plain hljs">
   ╭────┏━━━━━━┓────╮
   │dcba┃abcdef┃fedc│
   ╰────┗━━━━━━┛────╯
</code></pre><p>See also: <a href="#ImageFiltering.Fill"><code>Fill</code></a>,<a href="#ImageFiltering.padarray"><code>padarray</code></a>, <a href="#ImageFiltering.Inner"><code>Inner</code></a> and <a href="#ImageFiltering.NoPad"><code>NoPad</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/border.jl#L32-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.padarray" href="#ImageFiltering.padarray"><code>ImageFiltering.padarray</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">padarray([T], img, border)</code></pre><p>Generate a padded image from an array <code>img</code> and a specification <code>border</code> of the boundary conditions and amount of padding to add.</p><p>Return a padded image. The function supports one, two or multi-dimensional images. You can specify the element type <code>T</code> of the output image.</p><p>See <a href="#ImageFiltering.Pad"><code>Pad</code></a> and <a href="#ImageFiltering.Fill"><code>Fill</code></a> for details.</p><p><strong>Examples</strong></p><p><strong>Padding</strong></p><p>The main syntax for <code>Pad</code> is <code>(style, m, n, ...)</code> or <code>(style, (m, n))</code>, where <code>m</code> pixels are added to dimension 1 (top and bottom), <code>n</code> pixels for dimension 2, and so forth.</p><p>Add 30 to left and right, 40 to top and bottom:</p><pre><code class="language-julia hljs">padarray(A, Pad(:replicate, 30, 40))
padarray(A, Pad(:circular, 30, 40))
padarray(A, Pad(:symmetric, 30, 40))
padarray(A, Pad(:reflect, 30, 40))</code></pre><p>Add 30 above, 40 to left, 50 to bottom, 60 to right:</p><pre><code class="language-julia hljs">padarray(A, Pad(0, (30, 40), (50, 60)))
padarray(A, Pad(0, (30, 40), (50, 60)))</code></pre><p><strong>3D</strong></p><pre><code class="language-julia hljs">padarray(A, Pad(:replicate, 1, 1, 1)) 
padarray(A, Fill(0, (1, 1, 1))) </code></pre><p><strong>Filling</strong></p><p>The main syntax for <code>Fill</code> is <code>(value, m, n)</code> or <code>(value, (m, n))</code> where the image is prepended by <code>m</code> pixels and appended by <code>n</code> pixels in each dimension.</p><p>Add 20 <code>-1</code> values above, 30 to left, 40 to bottom, 50 to right:</p><pre><code class="language-julia hljs">padarray(A, Fill(-1, (20, 30), (40, 50))) </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/border.jl#L270-L323">source</a></section></article><h2 id="Find-local-extrema"><a class="docs-heading-anchor" href="#Find-local-extrema">Find local extrema</a><a id="Find-local-extrema-1"></a><a class="docs-heading-anchor-permalink" href="#Find-local-extrema" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.findlocalmaxima" href="#ImageFiltering.findlocalmaxima"><code>ImageFiltering.findlocalmaxima</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findlocalmaxima(img; window=default_window(img), edges=true) -&gt; Vector{CartesianIndex}</code></pre><p>Returns the coordinates of elements whose value is larger than all of their immediate neighbors. <code>edges</code> is a Boolean specifying whether to include the first and last elements of each dimension, or a tuple-of-Bool specifying edge behavior for each dimension separately.</p><p>The <code>default_window</code> is 3 for each spatial dimension of <code>img</code>, and 1 otherwise, implying that maxima are detected over nearest-neighbors in each spatial &quot;slice&quot; by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/extrema.jl#L106-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.findlocalminima" href="#ImageFiltering.findlocalminima"><code>ImageFiltering.findlocalminima</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findlocalminima(img; window=default_window(img), edges=true) -&gt; Vector{CartesianIndex}</code></pre><p>Like <a href="#ImageFiltering.findlocalmaxima"><code>findlocalmaxima</code></a>, but returns the coordinates of the smallest elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/extrema.jl#L120-L124">source</a></section></article><h2 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Algorithm.FIR" href="#ImageFiltering.Algorithm.FIR"><code>ImageFiltering.Algorithm.FIR</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Filter using a direct algorithm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/ImageFiltering.jl#L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Algorithm.FFT" href="#ImageFiltering.Algorithm.FFT"><code>ImageFiltering.Algorithm.FFT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Filter using the Fast Fourier Transform</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/ImageFiltering.jl#L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Algorithm.IIR" href="#ImageFiltering.Algorithm.IIR"><code>ImageFiltering.Algorithm.IIR</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Filter with an Infinite Impulse Response filter</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/ImageFiltering.jl#L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Algorithm.Mixed" href="#ImageFiltering.Algorithm.Mixed"><code>ImageFiltering.Algorithm.Mixed</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Filter with a cascade of mixed types (IIR, FIR)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/ImageFiltering.jl#L62">source</a></section></article><h2 id="Solvers-for-predefined-models"><a class="docs-heading-anchor" href="#Solvers-for-predefined-models">Solvers for predefined models</a><a id="Solvers-for-predefined-models-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers-for-predefined-models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Models" href="#ImageFiltering.Models"><code>ImageFiltering.Models</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This submodule provides predefined image-related models and its solvers that can be reused by many image processing tasks.</p><ul><li>solve the Rudin Osher Fatemi (ROF) model using the primal-dual method: <a href="#ImageFiltering.Models.solve_ROF_PD-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{Any}}} where T"><code>solve_ROF_PD</code></a> and <a href="#ImageFiltering.Models.solve_ROF_PD!-Union{Tuple{T}, Tuple{AbstractArray{T}, Tuple, AbstractArray, Real, Integer}} where T"><code>solve_ROF_PD!</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/models.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Models.solve_ROF_PD!-Union{Tuple{T}, Tuple{AbstractArray{T}, Tuple, AbstractArray, Real, Integer}} where T" href="#ImageFiltering.Models.solve_ROF_PD!-Union{Tuple{T}, Tuple{AbstractArray{T}, Tuple, AbstractArray, Real, Integer}} where T"><code>ImageFiltering.Models.solve_ROF_PD!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve_ROF_PD!(out, buffer, img, λ, num_iters)</code></pre><p>The in-place version of <a href="#ImageFiltering.Models.solve_ROF_PD-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{Any}}} where T"><code>solve_ROF_PD</code></a>.</p><p>It is not uncommon to use ROF solver in a higher-level loop, in which case it makes sense to preallocate the output and intermediate arrays to make it faster.</p><div class="admonition is-info"><header class="admonition-header">Buffer</header><div class="admonition-body"><p>The content and meaning of <code>buffer</code> might change without any notice if the internal implementation is changed. Use <code>preallocate_solve_ROF_PD</code> helper function to avoid potential changes.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using ImageFiltering.Models: preallocate_solve_ROF_PD

out = similar(img)
buffer = preallocate_solve_ROF_PD(img)
solve_ROF_PD!(out, buffer, img, 0.2, 30)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/models.jl#L90-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.Models.solve_ROF_PD-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{Any}}} where T" href="#ImageFiltering.Models.solve_ROF_PD-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{Any}}} where T"><code>ImageFiltering.Models.solve_ROF_PD</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve_ROF_PD([T], img::AbstractArray, λ; kwargs...)</code></pre><p>Return a smoothed version of <code>img</code>, using Rudin-Osher-Fatemi (ROF) filtering, more commonly known as Total Variation (TV) denoising or TV regularization. This algorithm is based on the primal-dual method.</p><p>This function applies to generic N-dimensional colorant array and is also CUDA-compatible. See also <a href="#ImageFiltering.Models.solve_ROF_PD!-Union{Tuple{T}, Tuple{AbstractArray{T}, Tuple, AbstractArray, Real, Integer}} where T"><code>solve_ROF_PD!</code></a> for the in-place version.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>: the output element type. By default it is <code>float32(eltype(img))</code>.</li><li><code>img</code>: the input image, usually a noisy image.</li><li><code>λ</code>: the regularization coefficient. Larger <code>λ</code> results in more smoothing.</li></ul><p><strong>Parameters</strong></p><ul><li><code>num_iters::Int</code>: The number of iterations before stopping.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using ImageFiltering
using ImageFiltering.Models: solve_ROF_PD
using ImageQualityIndexes
using TestImages

img_ori = float.(testimage(&quot;cameraman&quot;))
img_noisy = img_ori .+ 0.1 .* randn(size(img_ori))
assess_psnr(img_noisy, img_ori) # ~20 dB

img_smoothed = solve_ROF_PD(img_noisy, 0.015, 50)
assess_psnr(img_smoothed, img_ori) # ~27 dB

# larger λ produces over-smoothed result
img_smoothed = solve_ROF_PD(img_noisy, 5, 50)
assess_psnr(img_smoothed, img_ori) # ~21 dB</code></pre><p><strong>Extended help</strong></p><p>Mathematically, this function solves the following ROF model using the primal-dual method:</p><p class="math-container">\[\min_u \lVert u - g \rVert^2 + \lambda\lvert\nabla u\rvert\]</p><p><strong>References</strong></p><ul><li>[1] Chambolle, A. (2004). &quot;An algorithm for total variation minimization and applications&quot;. <em>Journal of Mathematical Imaging and Vision</em>. 20: 89–97</li><li>[2] <a href="https://en.wikipedia.org/wiki/Total_variation_denoising">Wikipedia: Total Variation Denoising</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/models.jl#L20-L72">source</a></section></article><h2 id="Internal-machinery"><a class="docs-heading-anchor" href="#Internal-machinery">Internal machinery</a><a id="Internal-machinery-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-machinery" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ImageFiltering.KernelFactors.ReshapedOneD" href="#ImageFiltering.KernelFactors.ReshapedOneD"><code>ImageFiltering.KernelFactors.ReshapedOneD</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReshapedOneD{N,Npre}(data)</code></pre><p>Return an object of dimensionality <code>N</code>, where <code>data</code> must have dimensionality 1. The axes are <code>0:0</code> for the first <code>Npre</code> dimensions, have the axes of <code>data</code> for dimension <code>Npre+1</code>, and are <code>0:0</code> for the remaining dimensions.</p><p><code>data</code> must support <code>eltype</code> and <code>ndims</code>, but does not have to be an AbstractArray.</p><p>ReshapedOneDs allow one to specify a &quot;filtering dimension&quot; for a 1-dimensional filter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/blob/3b3d88ad04c0a981f76d5c43df51f63c96fc7447/src/kernelfactors.jl#L38-L51">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../technical/">« Technical overview</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Monday 28 April 2025 22:34">Monday 28 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
